<?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >
  <!--Note: keep the MD name convenient for users.-->

<!--@doc-title Simple Menu API -->
<!--@doc-overview
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

After creation, widgets may be partially updated at any time. This is
detailed in the Update_Widget cue.    

Note: raise_lua_event only supports passing strings, numbers, or components.
This api will pass complex tables of args using a blackboard var:
  player.entity.$simple_menu_args
  
-->
  
  
<!--@doc-section
### Widget arguments and properties overview
    
Many of the following cues share some common arguments or arg data types, 
described here. Note: many of these can be replaced with a constant looked
up in the egosoft api backend Helper module. Possible options are included
at the end of this documentation.
    
API args (all widgets, partially for rows and menus)
  * col
    - Integer, column of the row to place the widget in.
    - Uses 1-based indexing.
    - Note: row columns may not always align with table columns:
      - This actually sets the widget as the Nth cell of the row,
      - Row column alignment with the table columns depends on the sizes of
        all prior row cells (as possibly adjusted by colSpan).
      - Eg. if the widget in col=1 had a colSpan=2, then a new col=2
        widget will align with table column 3.
    - Required for now.
  * colSpan = 1
    - Int, how many columns the widget will span.
  * id = none
    - String, unique identifier for the widget.
    - Optional, but needed for Update_Widget calls.
  * echo = none
    - Optional, May be any data type.
    - This is returned in the table sent to signalled callback cues,
      for user convenience.
    
Widget properties (all widgets)
  * scaling = true
    - Bool, coordinates and dimensions will be scaled by the ui scaling factor.
  * width, height = 0
    - Ints, widget dimension overrides.
  * x, y = 0
    - Ints, placement offsets.
  * mouseOverText = ""
    - String, text to display on mouseover.
        
Cell properties (all widgets)
  * cellBGColor = 'Color.row_background'
    - Color, cell background color.
  * uiTriggerID = none
    - String, if present then this is the control field for ui
      triggered events on widget activations.
    - Ignore for now; api handles callback cues directly.
        
Events (depends on widget)
  * on<___> (onClick, onTextChanged, etc.)
    - Optional callback cue.
    - When the player interacts with most widgets, ui events will occur.
      On such events, a provided cue will be called with the event results.
    - Most event.param tables will include these fields:
      * row, col
        - Longfloat, coordinate of the activated widget.
        - Primarily for use by this backend.
      * id
        - String id given to the widget at creation, or null.
      * event
        - String, name of the event, matching the arg name.
        - Eg. "onClick".
      * echo
        - Same as the "echo" arg provided to widget creation.
    - Extra contents of the event.param are described per widget below.
        
Misc properties (depends on widget):
  * font
    - String, font to use.
    - Typical options: 
      - "Zekton"
      - "Zekton bold"
      - "Zekton fixed"
      - "Zekton bold fixed"
      - "Zekton outlined"
      - "Zekton bold outlined"
  * fontsize
    - Int, typically in the 9 to 12 range.
  * halign
    - String, text alignment, one of ["left", "center", "right"].
  * minRowHeight
    - Int, minimal row height, including y offset.
        
Complex properties:
  * Color
    - Table of ["r", "g", "b", "a"] integer values in the 0-255 range.
  * TextProperty
    - Table describing a text field.
    - Note: in some widgets "text" is a string, others "text" is
      a TextProperty table.
    - Fields:
      * text = ""
      * halign = 'Helper.standardHalignment'
      * x = 0
      * y = 0
      * color = 'Color.text_normal'
      * glowfactor = 'Color.text_normal.glow'
      * font = 'Helper.standardFont'
      * fontsize = 'Helper.standardFontSize'
      * scaling = true
  * IconProperty
    - Table describing an icon.
    - Fields:
      * icon = ""
        - Icon name
        - See libraries/icons.xml for options.
      * swapicon = ""
      * width = 0
      * height = 0
      * x = 0
      * y = 0
      * color = 'Color.icon_normal'
      * glowfactor = 'Color.icon_normal.glow'
      * scaling = true
  * HotkeyProperty
    - Table describing an activation hotkey.
    - See libraries/contexts.xml for potential options.
    - Note: hotkeys have not yet worked in testing.
    - Fields:
      * hotkey = ""
        - String, the hotkey action, matching a valid INPUT_STATE.
      * displayIcon = false
        - Bool, if the widget displays the associated icon as a hotkey.
      * x = 0
      * y = 0
        - Offsets of the icon if displayIcon is true.
  * StandardButtonProperty
    - Table specifying which menu level buttons to include.
    - Fields:
      * close = true
      * back = true
      * minimize = false
  * FrameTextureProperty
    - Table describing a frame background or overlay texture.
    - Fields:
		  * icon = ""
		  * color = 'Color.frame_background_default'
		  * width = 0
		  * height = 0
		  * rotationRate = 0
		  * rotationStart = 0
		  * rotationDuration = 0
		  * rotationInterval = 0
		  * initialScaleFactor = 1
		  * scaleDuration = 0
		  * glowfactor = 'Color.frame_background_default.glow'
-->


<cues>

  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.sn_mod_support_apis.lua.simple_menu.Interface'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu.
    * current, next
      - Ints, 1 or 2, indexes into the next few lists to select entry
        associated with the current or next menu.
      - At init, both == 1.
      - When a menu is being created, 'next' will increment and all new
        properties recorded to next.
      - When callbacks occur, 'current' is used.
      - When lua confirms it is opening the menu (might be delayed from md
        sending command), 'current' will increment to catch up to the most
        recent 'next'.
      - The motivation for this is cases where one custom menu is opened
        over top of another, and the old one will still need its data
        available to handle final callbacks (notably onCloseElement).
      - TODO: think if there is a cleaner way to do this.
    * row
      - Two entry list (for current/next), with following contents per entry:
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * menu_properties
      - Two entry list, with following contents per entry:
      - Table holding the menu creation args of the current menu.
    * widget_properties
      - Two entry list, with following contents per entry:
      - Table of tables of properties provided by the user for widgets, 
        annotated with additional information (eg. row number).
      - Holds shallow copies of the user args tables.
      - Outer table keyed by widget row, inner table by widget column.
      - Outer table may also be keyed by widget id, when the user provides
        an id string; in such cases the widget properties table will be
        recorded twice (by id and row/col).
      - Locally used for the callback cue storage, with echoing behavior
        intended to aid the user in handling callbacks.
    * row_properties
      - Two entry list, with following contents per entry:
      - List holding the properties for each row, in order.
      
    Additionally, complex data will be sent to lua using a blackboard var:
    * player.entity.$simple_menu_args
      - List of tables (or none), args sent with lua commands.
      - The list is appended to here, copied and deleted in lua.
      - The list is used to account for (common) cases where multiple commands
        are sent in the same frame, since the lua will only process them late
        in the frame, requiring arg buffering.
      - Since lua cannot edit the list directly, and cannot replace it with
        a modified list, it will just delete this var after reading it.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Simple_Menu'" control="'reloaded'" />
        </conditions>
        <actions>
          <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <!-- Note: Simple_Menu_Options can/will overwrite this. -->
      <set_value name="Globals.$DebugChance" exact="0" />
      <set_value name="Globals.$current" exact="1" />
      <set_value name="Globals.$next"    exact="1" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />
      <!-- The following are lists with two entries, initialized with dummies. -->
      <set_value name="Globals.$widget_properties"    exact="[null, null]" />
      <set_value name="Globals.$row_properties"       exact="[null, null]" />
      <set_value name="Globals.$row"                  exact="[null, null]" />
      <set_value name="Globals.$menu_properties"      exact="[null, null]" />
    </actions>
  </library>

  
  <!--@doc-cue
    Dummy cue used for signalling that the game or ui was reloaded.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!-- 
    Small helper function which will replace $args with an empty
    table if it is null.
    -->
  <library name="Init_Args_Table">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
    </actions>
  </library>
  
  <!-- 
    Lib helper for fill in default widget args.
    The args table should be in $args.
    Will automatically include a check for null args and init the table,
    so a call to Init_Args_Table isn't needed.
    TODO: remove cloning; Send_Command will do that.
  -->
  <library name="Fill_Widget_Default_Args">
    <actions>
      <include_actions ref="Init_Args_Table"/>
      <!-- Currently just set col to 1 by default. -->
      <do_if value="not $args.$col?">
        <set_value name="$args.$col" exact="1" />
      </do_if>
    </actions>
  </library>
  
  
  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Generic Command Cue
    -->
  
  <!-- Note: assume any users may call Send_Command directly, so do all special
  command handling here. -->
  <!--@doc-cue
    Generic cue for sending commands to lua. Other api cues redirect here
    to interface with the lua backend. Users may utilize this cue if they
    find it more convenient. See other cues for arg descriptions.
    
    Param: Table with the following items:
    * command
      - String, the command to send.
      - Supported commands:
        - Register_Options_Menu
        - Create_Menu
        - Close_Menu
        - Add_Submenu_Link
        - Add_Row
        - Make_Widget
        - Update_Widget
    * ...
      - Any args requied for the command.
      - Note: Make_Widget commands require a $type string to specify the
        widget type (found quoted in per-widget descriptions).
    -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- If the param is null, something went wrong in the call. TODO -->
      
      <!-- 
        Use a shallow copy for this, to avoid errors if the user reuses tables.
        This may be needed even if user reuses the table to make the same 
        widget on next menu opening, since this code might get confused
        by eg. auto $row inclusion below.
      -->
      <set_value name="$args" exact="event.param.clone" />
            
      <!-- The following command handlers are ordered most to least common. -->
      
      <!-- Handle widget arg recording. -->
      <do_if value="$args.$command == 'Make_Widget'">
        <!-- TODO: verify a $type was provided. -->
        
        <!-- Store the row in the args, for possible later lookup. -->
        <!-- TODO: support rows being specified ahead of time. -->
        <set_value name="$args.$row" exact="Globals.$row.{Globals.$next}" />
        
        <!-- Set any widget default args. Just col for now. -->
        <do_if value="not $args.$col?">
          <set_value name="$args.$col" exact="1" />
        </do_if>
        
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}.{Globals.$row.{Globals.$next}}.{$args.$col}" exact="$args" />
        <debug_text text="'Recorded args for row,col: (%s,%s)'.[Globals.$row.{Globals.$next}, $args.$col]"
                  chance="Globals.$DebugChance" filter="general"/>
        
        <!-- Also record by user id, if available. -->
        <do_if value="$args.$id?">
          <set_value name="Globals.$widget_properties.{Globals.$next}.{'$'+ $args.$id}" exact="$args" />
        </do_if>
      </do_if>
            
      <!-- Inc row counter. -->
      <do_elseif value="$args.$command == 'Add_Row'">
        <!-- 
          Update the row count, and expand the callback table.
          Note: since the global $row inits to 0, increment will go first to
          bring the first row up to 1 (1-based indexing).
          -->
        <set_value name="Globals.$row.{Globals.$next}" operation="add" />
        <set_value name="Globals.$widget_properties.{Globals.$next}.{Globals.$row.{Globals.$next}}" exact="table[]" />
        
        <!-- Store the properties for later lookup. -->
        <append_to_list name="Globals.$row_properties.{Globals.$next}" exact="$args"/>
      </do_elseif>      
           
      <!-- Handle standalone menu arg recording. TODO: merge in with options menus table. -->
      <do_elseif value="$args.$command == 'Create_Menu'">
        <!-- Inc 'next' with rollover, to point it at the menu data to overwrite. -->
        <set_value name="Globals.$next" exact="if (Globals.$next == 1) then 2 else 1"/>
          
        <!-- Setup fresh globals. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}" exact="table[]" />
        <set_value name="Globals.$row_properties.{Globals.$next}" exact="[]" />
        <set_value name="Globals.$row.{Globals.$next}" exact="0" />
        <set_value name="Globals.$menu_properties.{Globals.$next}" exact="$args"/>
      </do_elseif>
            
      <!-- Handle options menu arg recording. -->
      <do_elseif value="$args.$command == 'Register_Options_Menu'">
        <!-- Record the args using the menu id, $ prefixed. -->
        <set_value name="Globals.$options_submenu_specs.{'$'+event.param.$id}" exact="$args" />
      </do_elseif>      
      
      <!-- Args are transmitted to lua using a blackboard var. -->
      <!-- Create the blackboard list if it doesn't exist. -->
      <do_if value="not player.entity.$simple_menu_args?">
        <set_value name="player.entity.$simple_menu_args" exact="[]" />
      </do_if>
      <append_to_list name="player.entity.$simple_menu_args" exact="$args"/>

      <debug_text text="'Sending Process_Command with args: %s'.[$args]"
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'"/>
    </actions>
  </cue>

  
  
  <!-- ################################################################### -->
  <!--                            Menu Setup                               -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Menu Creation Cues
    -->
  
  <!--TODO: frame+table general properties.-->
  <!--TODO: ways to change some defaults, notable text.-->
  <!--@doc-cue
    Create a fresh standalone menu.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Each menu created will internally be given a frame to hold a table
    in which widgets will be placed.  The frame and table properties
    are also set with this cue.
    
    Param: Table with the following items:
    * id, echo
      - Standard api args
    * columns
      - Integer, total number of columns in the menu table.
      - Max is 13 (as of x4 4.0).
    * title
      - Text to display in the table header.
    * width
      - Int, optional, menu width. Defaults to a predefined width.
    * height
      - Int, optional, menu height. Default expands to fit contents.
    * offsetX
    * offsetY
      - Ints, optional, amount of space between menu and screen edge.
      - Positive values taken from top/left of screen, negative values
        from bottom/right of screen.
      - Defaults will center the menu.
    * onCloseElement
      - Cue, optional, signalled when the menu is closed.
    * onRowChanged
      - Cue, optional, signalled when the player highlights a different
        row, either by clicking or using arrow keys.
      - This is the row that is highlighted.
      - Fires when the menu is first opened and a default row selected.
    * onColChanged
      - Cue, optional, signalled when the player highlights a different
        column, either by clicking or using arrow keys.
      - This will fire if the row changes and there is an interactive
        widget on the new row.
      - Does not fire when selecting a row with no interactive widgets.
    * onSelectElement
      - Cue, optional, signalled when the player selects a different element.
      - In practice, this appears to only work well for row selection.
      - An element is selected when:
        - It is clicked after already being highlighted.
        - 'Enter' is pressed with it highlighted.
      - Example use: the default options menu uses this to know when the
        player wants to open a submenu, eg. by 'selecting' Load Game.
    * frame
      - Subtable, properties for the frame, as follows:
		  * background
        - FrameTextureProperty
		  * background2
        - FrameTextureProperty
		  * overlay
        - FrameTextureProperty
      * standardButtons = 'Helper.standardButtons_CloseBack'
        - StandardButtonProperty
        - Which standard buttons will be included, eg. back/minimize/close.
        - These are generally placed in the top right.
      * standardButtonX = 0
        - Int, x offset for the buttons.
      * standardButtonY = 0
        - Int, y offset for the buttons.
      * showBrackets = false
        - Bool, if frame brackets will be shown.
      * closeOnUnhandledClick = false
        - Bool, if the menu triggers an onHide event if the player clicks
          outside of its area.
        - Pending development.
      * playerControls = false
        - Bool, if player controls are enabled while the menu is open.
        - Can use this to create an info menu in the corner while the
          player continues flying.
      * enableDefaultInteractions = true
        - Bool, if default inputs are enabled (escape, delete, etc.).
        - When false, these inputs have their normal non-menu effect,
          eg. escape will open the main options menu (which closes
          this menu automatically).
    * table
      - Subtable, properties for the table of widgets, as follows:
      * borderEnabled = true
        - Bool, if the table cells have a background color.
        - When set false, the mouse can no longer change row selection,
          only arrow keys can.
      * reserveScrollBar = true
        - Bool, if the table width reserves space for a scrollbar by
          adjusting column sizes.
      * wraparound = true
        - Bool, if arrow key traversal of table cells will wrap around edges.
      * highlightMode = "on"
        - String, controls highlighting behavior of table selections.
        - One of ["on","column","off","grey"]
          - "on"     : highlight row with blue box
          - "column" : highlight cell with blue box
          - "grey"   : highlight row with grey box
          - "off"    : no highlights of selected cell
      * multiSelect = false
        - Bool, whether the table allows selection of multiple cells.
      * backgroundID = ""
        - String, name of an icon to use as the background texture.
        - Set to a blank string to disable the background.
      * backgroundColor = 'Color.table_background_default'
        - Color of the background texture.
          
    onCloseElement event returns:
    * echo, event, id
    * reason 
      - String, reason for the closure.
      - "back" if the player pressed the back button, or pressed 'escape'
        with enableDefaultInteractions == true.
      - "close" if the player pressed the close button, pressed 'delete'
        with enableDefaultInteractions == true, or opened a different menu.
      - "minimize" if the player pressed the minimize button.
    
    onRowChanged event returns:
    * echo, event, id
    * row
      - Int, index of the newly highlighted row.
    * row_id
      - ID of the selected row, if available.
    * row_echo
      - Echo field of the row, if available.
    
    onColChanged event returns:
    * echo, event, id
    * row, col
      - Ints, row/col highlighted, generally corresponding to a widget.
    * widget_id
      - ID of the any selected widget at the give row/col, if available.
    * widget_echo
      - Echo field of the widget, if available.
    
    onSelectElement event returns:
    * echo, event, id
    * row
      - Int, index of the selected row.
    * row_id
      - ID of the selected row, if available.
    * row_echo
      - Echo field of the row, if available.
      
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Create_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Close_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--TODO: copy over some documentation from Make_Menu.-->
  <!--TODO: a way to dynamically condition when a menu is displayed, eg. only when debugging.-->
  <!--@doc-cue
    Register an options menu, which will be accessible as a submenu of
    the normal game options. These menus will be set to use the same
    visual style as the standard options menus, and so support a
    reduced set of args compared to standalone menus.
    
    Param: Table with the following items:
    * id
      - String, required unique identifier for this menu.
      - Needs to differ from egosoft menu names, as well as any other
        mod registered menus.
    * echo
      - Standard api args
    * title
      - Text to display in the table header.
    * columns
      - Integer, total number of columns in the menu table.
    * private
      - Int 0 or 1, optional, controls if the menu will be listed automatically
        in the general list of Extension Options menus.
      - Defaults to 0, non-private.
      - Set to private for submenus you will manually link to using
        Add_Submenu_Link.
    * onOpen
      - Cue to be called when the submenu is being opened by the player.
      - This cue should use addRow and Make_ functions to build the menu.
      - Do not call Create_Menu from this cue.
      - Widgets should be set up in the same frame; menu will display
        on the following frame.
      - The event.param will hold a table including $id, $echo, $columns.
    * onRowChanged
      - Same as for Create_Menu.
    * onColChanged
      - Same as for Create_Menu.
    * onSelectElement
      - Same as for Create_Menu.
    * table
      - Same as for Create_Menu.
      
      
    Call this each time the Reloaded cue is signalled. Example:
    ```xml
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $onOpen  = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    ```
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Register_Options_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--
    Display an options menu. Call this after all other widget creation
    cues.
    This is not for use with Standalone menus.
    
    -Removed; lua side does an automatic 1-frame delayed display() call.
    
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Display_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
    -->
  
  <!--@doc-cue
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu
    (normally with the private flag set).
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Submenu_Link'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--@doc-cue
    Refresh the current options menu by clearing its contents and
    calling the onOpen callback cue.  Does not change the depth of
    the options menu (eg. the back button is unaltered).
    
    For options menus only; standalone menus can refresh using
    a new call to Create_Menu.
    -->
  <cue name="Refresh_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Refresh_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- ################################################################### -->
  <!--                           Table stuff                               -->
  <!-- ################################################################### -->

  <!--@doc-section
    #### Table Cues
    -->

  <!--TODO: make rows selectable or not, set up echo and callbacks for
      RowSelected and similar events.-->
  <!--@doc-cue
    Add a row to the current menu.
    Following widget creation commands add to the most recently added row.
    Max is 160 rows (as of x4 4.0).
    
    Param: Table with the following items.
    * id, echo
      - Standard api args
    * selectable = true
      - Bool, if the row is selectable by the player.
      - Should always be true for rows with interactable widgets.
    * scaling = true
      - Bool, default ui scaling of cells (width/height/coordinates).
      - For now, this is expected to be overridden by per-widget settings.
    * fixed = false
      - Bool, fixes the row in place so it cannot be scrolled.
      - Requires prior rows also be fixed.
    * borderBelow = true
      - Shows a border gap before the next row, if present.
    * interactive = true
    * bgColor = 'Color.row_background'
      - Color, default background of the row's cells.
    * multiSelected = false
      - Bool, row is preselected for multiselect menu tables.
  },
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Row'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- TODO: maybe nice wrapper cues around this for each method. -->
  <!--@doc-cue
    Adjust some aspect of the table calling a backend table method.
    Generally for adjusting column widths.
    
    Param: Table with the following items.
    * method
      - String, name of the method being called.
      - Further args depend on the method, as follows:
    * ...
      - Further args depending on the method called.
      - Args described below.
      
    The possible methods are:
    - "setColWidth"
      * col
      - Int, column index to adjust. Indexing starts at 1.
      * width
        - Int, pixel width of column
      * scaling = true
        - Bool, if the width is ui scaled.          
    - "setColWidthMin"
      * col
      * width
        - Int, minimum pixel width of column
      * weight = 1
        - Int, how heavily this column is favored vs others when widths
          are calculated.
      * scaling = true
        - Bool, if the width is ui scaled.            
    - "setColWidthPercent"
      * col
      * width
        - Int, percent width of column of total table.          
    - "setColWidthMinPercent"
      * col
      * width
        - Int, percent width of column of total table.
      * weight = 1
        - Int, how heavily this column is favored vs others.          
    - "setDefaultColSpan"
      * col
      * colspan
        - Int, how many extra columns widgets created in this column
          will be stretched across.          
    - "setDefaultBackgroundColSpan"
      * col
      * bgcolspan
        - Int, how many extra columns the backgrounds of widgets created in
          this column will be stretched across.      
    -->
  <cue name="Call_Table_Method" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Call_Table_Method'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Widget Creation Cues
    -->
  
  
  <!--TODO: rendertarget (placeholder sizing widget)-->
  
  <!--@doc-cue
    Make a "text" cell for displaying non-interactive text.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign = 'Helper.standardHalignment'
    * color = Color.text_normal
      - Updateable
    * glowfactor = Color.text_normal.glow
    * titleColor
      - If given, puts the widget in title mode, which includes an
        automatic cell underline.
    * font = 'Helper.standardFont'
    * fontsize = 'Helper.standardFontSize'
    * wordwrap = false
    * textX = 'Helper.standardTextOffsetx'
    * textY = 'Helper.standardTextOffsety'
    * minRowHeight = 'Helper.standardTextHeight'
    
    
    Hint: egosoft menus make vertical space using wide, empty text cells.
    Example, assuming 2 table columns:
    ```xml      
      <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"
                            param ="table[$selectable = false]"/>
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Make_Text"
        param = "table[
          $col = 1, 
          $colSpan = 2,
          $height = 'Helper.borderSize',
          $fontsize = 1,
          $cellBGColor = 'Color.optionsmenu_cell_background',
          ]"/>
    ```
    -->
  <cue name="Make_Text" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'text'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "boxtext" cell.  Similar to text, but with an outlining box.
    Note: the outline box highlighting can behave oddly as the player
    interacts with other widgets.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color = 'Color.text_normal'
      - Updateable
    * glowfactor = 'Color.text_normal.glow'
    * boxColor = 'Color.boxtext_box_default'
      - Color of the surrounding box.
      - Updateable
    * minRowHeight = 'Helper.standardTextHeight'
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    -->
  <cue name="Make_BoxText" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'boxtext'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "button" cell.
    Adds to the most recent row.
    
    Param: Table with the following items.
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties   
    * onClick
      - Cue to callback when the button is left clicked.
    * onRightClick
      - Cue to callback when the button is right clicked.
    * text
      - TextProperty.
      - Updateable text and color
    * text2
      - TextProperty.
      - Updateable text and color
    * active = true
      - Bool, if the button is active.
      - Updateable
    * bgColor = 'Color.button_background_default'
      - Color of background.
      - Updateable
    * highlightColor = 'Color.button_highlight_default'
      - Color when highlighted.
      - Updateable
    * height = 'Helper.standardButtonHeight'
    * icon
      - IconProperty
    * icon2
      - IconProperty
    * hotkey
      - HotkeyProperty
      
      
    onClick event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'button'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make an "editbox" cell, for text entry.
    Adds to the most recent row.
    
    Warning: due to a (likely) typo bug, x4 is limited to 5 text edit boxes
    in a single menu.
    If many edit fields are needed, consider using sliders for numeric values
    (limit 50), where users can click the slider displayed value to use it
    like an editbox.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onTextChanged
      - Cue to call when the player changes the box text. 
      - Occurs on every letter change.
    * onEditBoxDeactivated
      - Cue to call when the player deselects the box.
      - Deselection may occur when selecting another element, pressing enter,
        or pressing escape.
      - Does not trigger if the menu is closed.
    * bgColor = 'Color.editbox_background_default'
      - Color of background.
    * closeMenuOnBack = false
      - Bool, if the menu is closed when the 'back' button is pressed while
        the editbox is active.
      - Description unclear.
    * defaultText
      - String, the default text to display when nothing present.
      - Updateable
    * textHidden = false
      - Bool, if the text is invisible.
    * encrypted = false
      - Bool, if the input has an encrypted style of display.
    * selectTextOnActivation = true
      - Bool, if the text is preselected on activation.
    * active = true
    * restoreInteractiveObject = false
      - Bool, if the focus is returned to the prior input object when
        this editBox is deactivated.
    * maxChars = 50
      - Int, maximum number of chars that may be entered.
    * text
      - TextProperty
    * hotkey
      - HotkeyProperty
      
      
    onTextChanged event returns:
    * row, col, echo, event, id
    * text
      - String, the new text in the box.
        
    onEditBoxDeactivated event returns:
    * row, col, echo, event, id
    * text
      - String, the current text in the box.
    * textchanged
      - Bool, if the text was changed since being activated.
    * wasconfirmed
      - Bool, false if the player pressed "escape", else true.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'editbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a horizontal "slidercell" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onSliderCellChanged
      - Cue to call when the slider value is changed.
      - When the player drags the slider around, this will be called
        repeatedly at intermediate points.
      - When the player types into the editbox, this will trigger on
        every typed character.
    * onSliderCellActivated
      - Cue to call when the player activates the slider.
    * onSliderCellConfirm
      - Cue to call when the player deactivates the slider.
      - Triggers less often than onSliderCellChanged.
      - Recommended to use this over other events.
    * bgColor = 'Color.slider_background_default'
      - Color of background.
    * inactiveBGColor = 'Color.slider_background_inactive'
    * valueColor = 'Color.slider_value'
      - Color of value.
    * posValueColor = 'Color.slider_diff_pos'
      - Color, positive value if fromCenter is true
    * negValueColor = 'Color.slider_diff_neg'
      - Color, negative value if fromCenter is true
    * min = 0
      - Min value the bar is sized for
    * max = 0
      - Max value the bar is sized for
      - Updateable
    * exceedMaxValue = false
      - Bool, if the player can go over the max value.
      - Requires min >= 0.
    * minSelect = none
      - Optional, Min value the player may select.
      - Defaults to min
    * maxSelect
      - Max value the player may select.
      - Defaults to max
      - Updateable
      - Do not use maxSelect if exceedMaxValue is true
    * hideMaxValue = false
      - Bool, hides the max value.
    * start = 0
      - Initial value
    * value
      - The current value of the slider.
      - Not used during setup (which instead uses start), but can be used
        to update the slider after creation.
      - Updateable
    * step = 1
      - Step size between slider points
    * suffix = ""
      - String, suffix on the displayed current value.
    * rightToLeft = false
      - Bool, enables a right/left mirrored bar.
    * fromCenter = false
      - Bool, bar extends from a zero point in the center.
    * readOnly = false
      - Bool, disallows player changes.
    * forceArrows = false
      - Bool, show force arrows in readOnly case.
    * useInfiniteValue = false
      - Bool, sets slider to show infinity when infiniteValue is reached.
    * infiniteValue = 0
      - Value at which to show infinity when useInfiniteValue is true.
    * useTimeFormat = false
      - Bool, sets the slider to use a time format.
    * text
      - TextProperty
    
    
    onSliderCellChanged event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
      
    onSliderCellActivated event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    * posx, posy
      - Coordinates of the widget (likely not useful).
      
    onSliderCellConfirm event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
    * valuechanged
      - Bool, true if the value changed since being activated.
      - If the player escapes out of the editbox, this will be false and
        the value will be the pre-edit value.
      
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'slidercell'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "dropdown" selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * options
      - List of tables describing each option.
      - Each subtable has these fields:
        * text = ""
          - String, option text.
        * icon = ""
          - String, icon name.
        * displayremoveoption = false
          - Bool, if true the option will show an 'x' that the player can
            click to remove it from the dropdown list.
        * ...
          - Similar to "echo", other subtable fields will be included
            in the cue callback.
    * onDropDownActivated
      - Cue to call when the player activates the dropdown.
    * onDropDownConfirmed
      - Cue to call when the player selects an option.
    * onDropDownRemoved
      - Cue to call when the player removes an option.
    * startOption = ""
      - String or number, id of the initially selected option.
      - Updateable
    * active = true
     - Bool, if the widget is active.
    * bgColor = 'Color.dropdown_background_default'
     - Color of background.
    * highlightColor = 'Color.dropdown_highlight_default'
     - Color when highlighted.
    * optionColor = 'Color.dropdown_background_options'
      - Color of the options.
    * optionWidth, optionHeight = 0
      - Dimensions of the options.
    * allowMouseOverInteraction = false
    * textOverride = ""
    * text2Override = ""
    * text
     - TextProperty
    * text2
     - TextProperty
    * icon
     - IconProperty
    * hotkey
     - HotkeyProperty
      
      
    onDropDownActivated event returns:
    * row, col, echo, event, id
        
    onDropDownConfirmed event returns:
    * row, col, echo, event, id
    * option_index
      - Number, index of the selected option.
    * option
      - Table, the original option specification subtable given to
        widget creation that matches the option_index.
      
    onDropDownRemoved event returns:
    * row, col, echo, event, id
    * option_index
      - Number, index of the selected option.
    * option
      - Table, the original option specification subtable given to
        widget creation that matches the player selection.
      
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'dropdown'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make an "icon" cell. Note: many icons are large, and may need explicit
    width/height to adjust the sizing.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * icon = ""
      - String, icon id
      - Updateable
    * color = 'Color.icon_normal'
      - Color
      - Updateable
    * glowfactor = 'Color.icon_normal.glow'
    * bgColor = 'Color.checkbox_background_default'
    * active = true
    * symbol = 'circle'
      - String, 'circle or 'arrow', the symbol shown in a checked box.
    * text
      - TextProperty
      - Updateable text
    * text2
      - TextProperty
      - Updateable text
    -->
  <cue name="Make_Icon" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'icon'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "checkbox" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onClick
      - Cue to callback when the checkbox is clicked.
    * checked = false
      - Bool or int, if checked initially.
      - Updateable
    * bgColor = 'Color.checkbox_background_default'
     - Color of background.
    * active = true
     - Bool, if the widget is active.
    * symbol = 'circle'
    * glowfactor = 'Color.icon_normal.glow'
     
    onClick event returns:
    * row, col, echo, event, id
    * checked
      - Int, 0 or 1, checkbox status after click.
      
    -->
  <cue name="Make_CheckBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'checkbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  
  <!--@doc-cue
    Make a "statusbar" cell. This is a bar that have a baseline value,
    is filled based on current value, and coloring is based on if the
    current is greater or less than the baseline.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * current = 0
      - Int, determines fill of the bar.
      - Updateable
    * start = 0
      - Int, baseline value of the bar. Coloring of bar depends on current
        compared to start.
      - Updateable
    * max = 0
      - Int, max value of the bar, used for graphic scaling.
      - Min value of the bar is always pinned at 0.
      - Updateable
    * valueColor = 'Color.statusbar_value_default'
      - Color
    * posChangeColor = 'Color.statusbar_diff_pos_default'
      - Color
    * negChangeColor = 'Color.statusbar_diff_neg_default'
      - Color
    * markerColor = 'Color.statusbar_marker_default'
      - Color
    * titleColor
      - Color, optional.
    -->
  <cue name="Make_StatusBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'statusbar'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!-- In development.
    Make a "shieldhullbar" cell, similar to that used on the map.
    May be linked to an object for a dynamic bar, or use fixed 
    percentages for a static var.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
      - Note: "height" behaves oddly and has not been fully figured out.
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * object = none
      - Optional, object to reference for dynamic shields and hull.
      - Updateable
    * shield = 0, hull = 0
      - Int, percentages 0 to 100, fixed shield or hull bar fullness when not
        giving a target.
      - Updateable
    * glowfactor = 'Color.icon_normal.glow'
    -->
  <cue name="Make_ShieldHullBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'shieldhullbar'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  

  <!--@doc-cue
    Update a widget's state after creation.
    
    Param: Table with the following items
    * id
      - String, original id assigned to the widget at creation.
    * ...
      - Any args to be updated, matching the original widget creation args
        layout.
      - Which widget properties can be updated depends on the specific widget.
  -->
  <cue name="Update_Widget" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param" />
      
      <!-- Look up the id in recorded widget properties. -->
      <!-- Skip if there is an id problem. -->
      <do_if value="$args.$id? and Globals.$widget_properties.{Globals.$current}.{'$'+ $args.$id}?">
        <set_value name="$args_table" exact="Globals.$widget_properties.{Globals.$current}.{'$'+ $args.$id}"/>
        
        <!-- Fill in the row/col for the lua to find this widget. -->
        <set_value name="$args.$row" exact="$args_table.$row" />
        <set_value name="$args.$col" exact="$args_table.$col" />
        
        <!-- Set command string. -->
        <set_value name="$args.$command" exact="'Update_Widget'" />
        
        <!-- Send it off. -->
      <signal_cue_instantly cue="Send_Command" param="$args"/>
      </do_if>
      
      <do_else>
        <debug_text text="'Found no widget with id: %s'.[$args.$id]"
                  chance="Globals.$DebugChance" filter="general"/>
      </do_else>

    </actions>
  </cue>
  
  
  <!-- ################################################################### -->
  <!--                             Callbacks                               -->
  <!-- ################################################################### -->
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets or the menu in general. Handle callbacks to user cues.
    
    The callback will echo the original widget args table, annotated with
    the data returned from lua. User code may use this feature to attach
    data to widgets at creation time, and use that echo'd data in
    callback handling.
        
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. For widget events, this table will
    always have $row and $col of the widget the player modified, along with
    any per-widget state information.  See other documentation on the
    expected returned fields for each event.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
      
      <!-- Handle menu events different than widgets. -->
      <do_if value="$response.$type == 'menu'">
        
        <!-- onOpen will just signal this api to advance to the next properties. -->
        <do_if value="$response.$event == 'onOpen'">
          <!-- Inc 'current' with rollover, to switch later events to next menu. -->
          <set_value name="Globals.$current" exact="if (Globals.$current == 1) then 2 else 1"/>
        </do_if>

        <do_else>
          <!-- Look up the callback cue. -->
          <!-- Use @, so if a cue isn't found this yields null. -->
          <set_value name="$cue" exact="@Globals.$menu_properties.{Globals.$current}.{'$' + $response.$event}" />

          <!-- Handle the callback, if found and still existing. -->
          <do_if value="$cue.exists">
            <debug_text text="'Calling %s'.[$cue]"
                  chance="Globals.$DebugChance" filter="general"/>
                    
            <!-- Add the $echo to the response, or null. -->
            <set_value name="$response.$echo" exact="@Globals.$menu_properties.{Globals.$current}.$echo" />
            <!-- Add the $id to the response, or null. -->
            <set_value name="$response.$id" exact="@Globals.$menu_properties.{Globals.$current}.$id" />
          
            <!-- onRowChanged and onSelectElement will look up any extra row info. -->
            <do_if value="($response.$event == 'onRowChanged') or ($response.$event == 'onSelectElement')">
              <!-- Add the row $echo to the response, or null. -->
              <set_value name="$response.$row_echo" exact="@Globals.$row_properties.{Globals.$current}.{$response.$row}.$echo" />
              <!-- Add the row $id to the response, or null. -->
              <set_value name="$response.$row_id" exact="@Globals.$row_properties.{Globals.$current}.{$response.$row}.$id" />              
            </do_if>
          
            <!-- onColChanged wants to look up widget info. -->
            <do_elseif value="$response.$event == 'onColChanged'">
              <!-- Add the widget $echo to the response, or null. -->
              <set_value name="$response.$widget_echo" exact="@Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}.$echo" />
              <!-- Add the widget $id to the response, or null. -->
              <set_value name="$response.$widget_echo" exact="@Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}.$id" />
            </do_elseif>
          
            <!-- Make the callback. -->
            <signal_cue_instantly cue="$cue" param="$response" />
          </do_if>
        
          <!-- Print warning if no callback valid, if one was given.-->
          <do_else>
            <do_if value="Globals.$menu_properties.{Globals.$current}.{'$' + $response.$event}?">
              <debug_text text="'Invalid callback for menu event: ' + $response.$event"
                    chance="Globals.$DebugChance" filter="general"/>
            </do_if>
          </do_else>
        </do_else>
        
      </do_if>
      
      
      <!-- Handle widget events. -->
      <do_else>
        <!-- Look up the callback cue for this row/col and event. -->
        <!-- Use @, so if a cue isn't found this yields null. -->
        <set_value name="$args_table" exact="Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}" />
        <set_value name="$cue" exact="@$args_table.{'$' + $response.$event}" />
      
        <!-- Handle the callback, if found and still existing. -->
        <do_if value="$cue.exists">
          <debug_text text="'Calling %s'.[$cue]" 
                chance="Globals.$DebugChance" filter="general"/>
              
          <!-- Add the $echo to the response, or null. -->
          <set_value name="$response.$echo" exact="@$args_table.$echo" />

          <!-- Add the $id to the response, or null. -->
          <set_value name="$response.$id" exact="@$args_table.$id" />
          
          <!-- If this was a dropdown menu, add the option subtable. -->
          <do_if value="$args_table.$type == 'dropdown'">
            <!-- The response has the index of the selected option. -->
            <set_value name="$response.$option" exact="$args_table.$options.{$response.$option_index}"/>
          </do_if>

          <!-- Make the callback. -->
          <signal_cue_instantly cue="$cue" param="$response"/>
        </do_if>
      
        <!-- Print warning if no callback valid, but one was given. -->
        <do_else>
          <do_if value="$args_table.{'$' + $response.$event}?">
            <debug_text text="'Invalid callback for row,col: (%s,%s)'.[$response.$row, $response.$col]"
                  chance="Globals.$DebugChance" filter="general"/>
          </do_if>
          <!--<do_else>
            <debug_text text="'No callback for row,col: (%s,%s) in %s'.[$response.$row, $response.$col, $args_table]"
                  chance="Globals.$DebugChance" filter="general"/>
          </do_else>-->
        </do_else>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
    This will have somewhat similar behavior to Create_Menu (doing a reset
    for the fields that capture the new table properties).
    Calls the user callback cue to trigger menu building.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />
      
      <!--Look up the args for this menu id. Suppress if not found.-->
      <set_value name="$menu_properties" exact="@Globals.$options_submenu_specs.{'$'+$id}"/>

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a menu or cue isn't found this yields null. -->
      <set_value name="$cue" exact="@$menu_properties.$onOpen" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">

        <!-- Inc 'next' with rollover, to point it at the menu data to overwrite. -->
        <set_value name="Globals.$next" exact="if (Globals.$next == 1) then 2 else 1"/>

        <!-- Setup fresh globals. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}" exact="table[]" />
        <set_value name="Globals.$row_properties.{Globals.$next}" exact="[]" />
        <set_value name="Globals.$row.{Globals.$next}" exact="0" />
        <!-- Link menu_properties to the args registered. -->
        <set_value name="Globals.$menu_properties.{Globals.$next}" exact="$menu_properties"/>

        <!--Set up the signal param.-->
        <set_value name="$event_param" exact="table[
                   $id      = @$menu_properties.$id,
                   $echo    = @$menu_properties.$echo,
                   $columns = @$menu_properties.$columns,
                   ]"/>

        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="$event_param"/>     
      </do_if>
      
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  
  <!-- ################################################################### -->
  <!--                             Extra Docs                              -->
  <!-- ################################################################### -->
  <!--Note: put these inside cues, due to doc gen parsing top level then cue level.-->

  <!--@doc-section
  #### Helper Consts

  In the egosoft backend, there is a "Helper" module which defines many
  constants used in the standard menus such as fonts, etc. Colors are
  available in lua through the Color global, with fields defined
  in the libraries/colors.xml mapping entries (but the color entries
  are not accessible).
  Arguments may optionally be given as a string matching a Helper const,
  eg. 'Helper.standardFontBold', or a Color const, 
  eg. 'Color.row_separator_white'.
  A selected list of possibly useful helper consts follows (and may be
  out of date with the current patch).
  
  * Font related
    - Helper.standardFontBold = "Zekton bold"
    - Helper.standardFontMono = "Zekton fixed"
    - Helper.standardFontBoldMono = "Zekton bold fixed"
    - Helper.standardFontOutlined = "Zekton outlined"
    - Helper.standardFontBoldOutlined = "Zekton bold outlined"
    - Helper.standardFont = "Zekton"
    - Helper.standardFontSize = 9
    - Helper.standardTextOffsetx = 5
    - Helper.standardTextOffsety = 0
    - Helper.standardTextHeight = 16
    - Helper.standardTextWidth = 0
    - Helper.titleFont = "Zekton bold"
    - Helper.titleFontSize = 12
    - Helper.titleOffsetX = 3
    - Helper.titleOffsetY = 2
    - Helper.titleHeight = 20
    - Helper.headerRow1Font = "Zekton bold"
    - Helper.headerRow1FontSize = 10
    - Helper.headerRow1Offsetx = 3
    - Helper.headerRow1Offsety = 2
    - Helper.headerRow1Height = 20
    - Helper.headerRow1Width = 0
  
  * Sizing
    - Helper.standardButtonWidth = 30
    - Helper.standardButtonHeight = 20
    - Helper.standardFlowchartNodeHeight = 30
    - Helper.standardFlowchartConnectorSize = 10
    - Helper.standardHotkeyIconSizex = 19
    - Helper.standardHotkeyIconSizey = 19
    - Helper.subHeaderHeight = 18
    - Helper.largeIconFontSize = 16
    - Helper.largeIconTextHeight = 32
    - Helper.configButtonBorderSize = 2
    - Helper.scrollbarWidth = 19
    - Helper.buttonMinHeight = 23
    - Helper.standardIndentStep = 15
    - Helper.borderSize = 3
    - Helper.slidercellMinHeight = 16
    - Helper.editboxMinHeight = 23
    - Helper.sidebarWidth = 40
    - Helper.frameBorder = 25
    
  * StandardButtonProperty
    - Helper.standardButtons_CloseBack
    - Helper.standardButtons_Close
  
  -->
  <!--TODO: how to support Helper tables of Text cell args.-->

</cues>
  
</mdscript>