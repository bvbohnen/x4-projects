<?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Hotkey_API"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<!--Note: keep the MD name convenient for users.-->

<!--@doc-title Hotkey API -->
<!--
MD API support for making custom hotkeys.
This makes use of the Named Pipe API and an external python server.
Python will handle keypress detection, and will transmit to this MD script
which in turn handles callbacks to user specified cues.

-->
  <!--
TODO:
  - Option to hide an action (make private) from the menu.
-->
<cues>

  <!-- ################################################################## -->
  <!--                              Init                                  -->
  <!-- ################################################################## -->

    
  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                        param="'extensions.sn_mod_support_apis.lua.hotkey.Interface'"/>
    </actions>
  </cue>


  <!--
  Register the pipe server with the python host.
  -->
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly
        cue="md.Pipe_Server_Host.Register_Module"
        param="'extensions/sn_mod_support_apis/python/Send_Keys.py'"/>
    </actions>
  </cue>

  <!--
      Text storage cue, for easier lookup in general.
      Members are descriptive names of the text strings, prefixed with $.
    -->
  <cue name="Text"/>
  <library name="Load_Text">
    <actions>
      <set_value exact="{68537, 1010}" name="Text.$Debug" />
      <set_value exact="{68537, 1021}" name="Text.$option_debug_enable" />
      <set_value exact="{68537, 1012}" name="Text.$option_debug_enable_mouseover" />
    </actions>
  </library>


  <!--
  Static cue that holds some shared state information or constants.
  When this script is installed, a new instance of this cue is created,
  and will afterwards be live until the script is removed.
  Globals reset each time the game is loaded, to enable easy changing
  of constants.
    
  * DebugChance
    - 0 or 100
    
  * action_registry
    - Table of tables, with each subtable describing an action.
    - Keys are the action ids.
    - See Register_Action for description of fields.
           
  * key_event_action_registry
    - Table, indexed by key/event descriptor (string), holding a list of
      action ids attached to it.
    - Descriptors are made up of the key combo string, followed by the
      name of an event type (onPress, etc.).
    - Key descriptors have an extra '$' prefixed, due to x4 quirkiness.
    - A action may be used in multiple entries if it is enabled for
      multiple events.
    - Normally expect only one action to be registered per key, but it
      might be higher.
    - May have a mix of player-assigned and mod-assigned links.
    - Keys with no registered cues should be removed.
    - If table is empty, no keys are being listened to.
    - Note: this may be filled during init prior to actions being
      registered, which is okay.
      
  * key_event_substrings
    - Table, keyed the same as key_event_action_registry, simply holding
      a two item list of [key_name, event_name], the key_event name
      components.
    - Purely for convenience, as an alternative to overcomplicating
      the above registry with table or list entries.
    - Will be allowed to grow beyond keys currently in use.
        
  * player_action_keys
    - Table of player assigned key descriptors, keyed by action id.
    - Saved across reloads.
    - Saving is done in md (naturally), and in lua using userdata.xml.
    - On lua reload, it will read userdata and send over the found keys
      if it wasn't empty, prior to signalling 'reloaded'.
    - TODO: drop support for md saving
    - Lua will have a mirrored copy of this, and is primarily responsible
      for changing it or initializing entries.
    - Note: a single action may have multiple keys (2 through ui).
    - Each entry is a subtable with:
      * id
        - String, action id.
      * inputs
        - List with two entries, subtables describing the key.
        - Indices match up to the menu columns (left/right), supporting two
          player keys per action.
        - Fields per subtable:
          * combo
            - String, pipe server understood key combo.
            - Generated from the ego code.
            - Currently, this is "code <source> <code> <signum>", to be
              unpacked in python.
          * code
            - Int, ego style key code.
            - See https://github.com/wgois/OIS/blob/master/includes/OISKeyboard.h
              for the code mapping.
          * source
            - Int, ego style input source type.  1 for keyboard.
          * signum
            - Int, ego style signum (signed prefix), generally 0.
            
  * menu_states
    - Table, keyed by menu name (as registered with ego backend), holding
      'true' if the menu is open, else 'false'.
    - Minimized menus will be treated as closed.
  * in_menu
    - Bool, true if the player has a menu open.
    - Updated whenever menu_states is changed, primarily to speedup checks
      during key handling.
  * in_protected_menu
    - Bool, true if the player is in a protected menu where actions
      are disabled globally.
    - Currently used for OptionsMenu, to menu-enabled actions causing
      problems when remapping keys.
  * disabled
    - Bool, true when the lua has requested hotkeys be disabled following
      a direct input event (eg. edit box text).
    - This will cause callbacks to be suppressed.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals for the pipe handler. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!-- Reset when the lua reloads. -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Hotkey'" control="'reloaded'" />
        </conditions>
        <actions>
          
          <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
          <include_actions ref="Reset_Globals"/>

          <!--Load in any saved userdata.-->
          <include_actions ref="Load_Userdata"/>
          
          <!-- Init the lua with the stored list of player keys. -->
          <set_value name="player.entity.$hotkey_api_player_keys_from_md" exact="$player_action_keys" />
          <raise_lua_event name="'Hotkey.Update_Player_Keys'"/>

          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!--Load any text.-->
      <include_actions ref="Load_Text"/>
      
      <set_value name="$action_registry" exact="table[]"/>
      <set_value name="$key_event_action_registry" exact="table[]"/>
      <set_value name="$key_event_substrings" exact="table[]"/>      
      <set_value name="$menu_states" exact="table[]"/>
      <set_value name="$in_menu" exact="false"/>
      <set_value name="$in_protected_menu" exact="false"/>
      <set_value name="$disabled" exact="false"/>

      <!-- TODO: somehow bounce this over to Server_Reader reliably.-->
      <set_value name="$DebugChance" exact="0" />

      <!-- Init the $player_action_keys if it doesn't exist. -Moved to userdata.
      <do_if value="not $player_action_keys?">
        <set_value name="$player_action_keys" exact="table[]"/>
      </do_if> -->
        
    </actions>
  </library>

  <!--Load in userdata, which is shared across saves.
      Values saves in userdata:
      - Globals.$player_action_keys
  -->
  <library name="Load_Userdata">
    <actions>
      <!--Set the default to init empty entries.-->
      <run_actions ref="md.Userdata.Read" result="$userdata">
        <param name="Owner" value="'sn_mod_support_apis'"/>
        <param name="Key" value="'hotkey_api'"/>
        <param name="Default" value="table[
                       $player_action_keys = table[],
                       ]"/>
      </run_actions>      
      <!--Extract fields.-->
      <set_value name="Globals.$player_action_keys" exact="$userdata.$player_action_keys"/>
    </actions>
  </library>

  <!--Trigger a lua update of userdata, setting it to save to uidata.xml.-->
  <library name="Update_Userdata">
    <actions>
      <run_actions ref="md.Userdata.Write">
        <param name="Owner" value="'sn_mod_support_apis'"/>
        <param name="Key" value="'hotkey_api'"/>
        <param name="Value" value="table[
               $player_action_keys = Globals.$player_action_keys,
               ]"/>
      </run_actions>
    </actions>
  </library>
    


  <!-- ################################################################## -->
  <!--                          Pipe Handling                             -->
  <!-- ################################################################## -->

  <!-- 
  Use the generic server reader library to handle the pipe.
  Needs a cue wrapping it, else get property errors on the library refs.
    -->
  <cue name="Server_Reader_Wrapper">
    <cues>
      <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
        <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
        <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
        <param name="Actions_On_Read"     value="Actions_On_Read"/>
      </cue>
    </cues>
  </cue>

  <library name="Actions_On_Reload">
    <actions>
      <!--TODO: how to get debugchance from Globals safely on first mod load.-->
      <set_value name="$Pipe_Name" exact="'x4_keys'" />
      <set_value name="$DebugChance" exact="0" />

      <!-- Make sure the read loop is started if there are keys tracked. -->
      <do_if value="md.Hotkey_API.Globals.$key_event_action_registry.keys.list.count != 0">
        <signal_cue cue="$Start_Reading" />
      </do_if>
      <!-- Disable the menu plugin. -->
      <raise_lua_event name="'Hotkey.Update_Connection_Status'" param="0"/>
    </actions>
  </library>
  
  <library name="Actions_On_Connect">
    <actions>
      <!-- Announce the wanted keys to the server. -->
      <signal_cue_instantly cue="md.Hotkey_API.Register_Keys_With_Server"/>
      <!-- Enable the menu plugin. -->
      <raise_lua_event name="'Hotkey.Update_Connection_Status'" param="1"/>
    </actions>
  </library>

  <!--TODO: break out the key handling from the pipe cue.-->
  <library name="Actions_On_Read">
    <actions>
      <!-- Bounce back to lua to separate the message. 
          TODO: somehow avoid the lua bounce and related frame delay;
          perhaps extend the pipe api to support a generic lua processing
          function automated as part of the read?
      -->
      <raise_lua_event name="'Hotkey.Process_Message'" param="event.param"/>
      <!--<signal_cue_instantly cue="md.Hotkey_API.Handle_Message" param="event.param"/>-->

      <!--Acknowledge this key was read.
        Note: this will not bother to check for errors. If the pipe dies,
        a read will fail and catch it. -->
      <signal_cue_instantly
        cue="md.Named_Pipes.Write"
        param="table[$pipe=$Pipe_Name, $msg='ack']"/>
    </actions>
  </library>


  <!-- Function to update the server list of registered keys. -->
  <cue name="Register_Keys_With_Server" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Suppress if not connected to server, to reduce log confusion. -->
      <do_if value="Server_Reader.$server_connected == 1">

        <!--Start by merging the keys together, semicolon separated. -->
        <set_value name="$joined_keys" exact="''" />
        <do_all exact="Globals.$key_event_action_registry.keys.list.count" counter="$i">
          <set_value name="$joined_keys"
            exact="$joined_keys + Globals.$key_event_action_registry.keys.list.{$i} + ';'"/>
        </do_all>

        <!-- Send this to the server. -->
        <signal_cue_instantly
          cue="md.Named_Pipes.Write"
          param="table[$pipe = Server_Reader.$Pipe_Name, $msg = 'setkeys:'+$joined_keys ]"/>

      </do_if>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                           User API                                 -->
  <!-- ################################################################## -->


  <!--@doc-cue
  Dummy cue used for signalling that the api reloaded.
  Users that are registering actions should listen to this
  cue being signalled.
  -->
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!--@doc-cue
    Function to register an action. These actions will be displayed
    in the api options menu for user assignment of a hotkey.
    This should be re-sent each time Reloaded is signalled.
    
    Param : Table with the following items:
    * id
      - String, unique identifier of this action.
      - Saved keys will map to ids; other fields may be changed.
    * name = id
      - String, name to use for the key in the menu.
      - If not given, defaults to the id.
    * description = ""
      - String, mouseover text use for the key in the menu.
    * category = null
      - String, optional category heading to use in the menu.
      - Hotkeys are displayed by sorted categories first, then sorted
        names.
    * onPress = null
      - Callback cue when the combo final key is pressed.
    * onRelease = null
      - Callback cue when the combo final key is released.
    * onRepeat = null
      - Callback cue when the combo final key is repeated while held.
      - Repeat delay and rate depend on OS settings.
    * echo
      - Anything; this will be passed to the callback cue.
    * contexts
      - List of strings, names of player contexts where the action is valid.
      - If not given, defaults to "['flying']".
      - Valid contexts:
        * 'flying'
          - While the player is piloting a ship.
        * 'walking'
          - While the player is on foot.
        * 'menus'
          - While the player is in any menu.
          - The OptionsMenu will be protected, with actions always disabled.
        * ...
          - Other entries are names of individual menus, as registered by
            the egosoft backend.
                
    Keypress events will return a table with these fields:
    * key
      - String, identifier of the key combination matched.
    * id
      - Matching id of the action. May be useful if one callback cue handles
        multiple actions.
    * context
      - String, the player context when this action was triggered.
      - Either one of ["flying", "walking", "menu"], or the name of the
        open menu matching an entry in menu_names.
    * event
      - String, name of the event that occured.
      - One of ["onPress", "onRelease", "onRepeat"].
    * echo
      - Copy of what was given to the action registration, or null.
    
    Usage example:
      ```xml
      <cue name="Register_Action" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Hotkey_API.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue = "md.Hotkey_API.Register_Action" 
            param="table[
              $id          = 'my_key',
              $onPress     = OnKeyPress,
              $name        = 'Test Key',
              $description = 'This key is just testing',
              $contexts    = ['flying','walking'],
              ]"/>
        </actions>
      </cue>
      ```
  -->
  <cue name="Register_Action" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$args" exact="event.param"/>
      
      <!-- TODO: maybe try this syntax for defaults.
      <do_for_each name="$key" valuename="$default" 
                   in="table[
                    $description   = '',
                    $contexts      = ['flying'],
                   ]">
        <set_value name="$args.{$key}" exact="if ($args.{$key}?) then $args.{$key} else $default"/>
      </do_for_each> -->
      
      <!-- Default args. -->
      <do_if value="not $args.$description?">
        <set_value name="$args.$description" exact="''"/>
      </do_if>
      <do_if value="not $args.$name?">
        <set_value name="$args.$name" exact="$args.$id"/>
      </do_if>
      <do_if value="not $args.$contexts?">
        <set_value name="$args.$contexts" exact="['flying']"/>
      </do_if>
      <do_if value="not $args.$echo?">
        <set_value name="$args.$echo" exact="null"/>
      </do_if>

      <!-- For easier usage, split standard and menu contexts. -->
      <!-- Any misc menu names are collected into a separate list. 
          This is done so at usage time, menu name checks can be more
          easily ignored if no names were given. -->
      <set_value name="$contexts" exact="[]"/>
      <set_value name="$menu_names" exact="[]"/>
      <!-- Convenience table keyed with standard context names to check. -->
      <set_value name="$std_contexts" exact="['flying','walking','menus']"/>

      <!-- Loop over the given list. -->
      <do_for_each name="$name" in="$args.$contexts">
        <!-- Check for standard names. -->
        <do_if value="$std_contexts.indexof.{$name} != 0">
          <append_to_list name="$contexts" exact="$name"/>
        </do_if>
        <!-- Otherwise this should be a menu name. -->
        <do_else>
          <append_to_list name="$menu_names" exact="$name"/>
        </do_else>
      </do_for_each>
      
      <!-- Store the new data format. -->
      <set_value name="$args.$contexts"   exact="$contexts"/>
      <!-- If menu_names is an empty list, ignore it. -->
      <do_if value="$menu_names.count ge 0">
        <set_value name="$args.$menu_names" exact="$menu_names"/>
      </do_if>
      
      <!-- Record it. -->
      <set_value name="Globals.$action_registry.{'$'+$args.$id}" exact="$args"/>
      <debug_text text="'Action %s registered with args: %s'.[$args.$id, $args]"
                  chance="Globals.$DebugChance" filter="general"/>
      
      <!-- If any player keys were saved for this action, apply them now. -->
      <do_if value="Globals.$player_action_keys.{'$'+$args.$id}?">
        <set_value name="$info" exact="Globals.$player_action_keys.{'$'+$args.$id}"/>
        <!-- Loop over the input list; up to 2 combos. -->
        <do_for_each name="$input" in="$info.$inputs">
          <!-- Skip if the combo is blank. -->
          <do_if value="$input.$combo != ''">
            <signal_cue_instantly cue="Register_Key" param="table[
                                  $id  = $info.$id,
                                  $key = $input.$combo, 
                                  ]"/>
          </do_if>
        </do_for_each>
      </do_if>
        
      <!-- Keep the lua updated. -->
      <!-- Passes it on a player blackboard var, which lua clears. -->
      <set_value name="player.entity.$hotkey_api_actions" exact="Globals.$action_registry" />
      <raise_lua_event name="'Hotkey.Update_Actions'"/>
      
      <!--Note: if this is the first registered action, at this point the action
          is registered, but a key is not set, and the server hasn't been
          connected (since it looks for actual keys to be registered).
          However, logic exists to suppress the menu hotkey displays if there
          is no connected server, to reduce confusion slightly.
          So, start the server connection now, regardless of registered keys,
          to find out if it can even make a connection, after which the menu
          to set hotkeys can be displayed.
          (This isn't needed once keys are registered and remembered, but
          does apply to new games or new installs of the extension.)
          -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
    </actions>
  </cue>


  <!--@doc-cue
  
    Function to register a key with an action.
    
    If this is the first key registered, it will start the key listening loop.
    This is used by the menu system to set up player custom keys, but may
    also be called by a user to directly assign a key to an action.
    Keys added by direct user calls will not be visible in the menu, and have
    fewer restrictions than the menu enforces.
    This should be re-sent each time Reloaded is signalled, and should follow
    the action's registration.
    
    Param  : Table with the following items:
    * key
      - String specifying the key/combo to capture.
    * id
      - String, id of the matching action sent to Register_Action.
      - The action should already exist.
      
    Usage example:
      ```xml
      <cue name="Register_Keys" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Hotkey_API.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Hotkey_API.Register_Key" 
            param="table[$key='shift w', $id='my_registered_key']"/>
        </actions>
      </cue>
      ```
    
    Key syntax:
    - Keys may be given singular or as a combination.
    - Combinations are space separated.
    - A combo is triggered when the last key is pressed while all prior keys
      are held.
      - Examples:
      - "shift ctrl k" : 'shift' and 'ctrl' held when 'k' pressed.
      - "space 5" : 'space' held when '5' pressed
    - Shift, alt, ctrl act as modifiers.
      - TODO: remove alt as a modifier, to better match x4 behavior.
    - Alphanumeric keys use their standard character.
    - Special keys use these names (from pynput with some additions):
      - alt
      - alt_l
      - alt_r
      - backspace
      - caps_lock
      - ctrl
      - ctrl_l
      - ctrl_r
      - delete
      - down
      - end
      - enter
      - esc
      - f1 - f20
      - home
      - insert
      - left
      - menu
      - num_lock
      - page_down
      - page_up
      - pause
      - print_screen
      - right
      - scroll_lock
      - shift
      - shift_l
      - shift_r
      - space
      - tab
      - up
      - num_0
      - num_1
      - num_2
      - num_3
      - num_4
      - num_5
      - num_6
      - num_7
      - num_8
      - num_9
      - num_.
      - num_+
      - num_-
      - num_*
      - num_/
      - num_enter
      - win_l
      - win_r

  -->
  <cue name="Register_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <!--<debug_text text="'params: %s.'.[event.param]" chance="Globals.$DebugChance" filter="general"/>-->

      <!-- Validate that a string was sent. Removed; buggy, typeof thinks some chars are not strings.
      <do_if value="(typeof event.param.$key) != datatype.string">
        <debug_text text="'Error, given key is not a string: %1'.[event.param.$key]"
                    chance="100" filter="error"/>
      </do_if> -->
       
      <!-- Adjust the key to prefix with a $ for x4 tables. -->
      <set_value name="$key" exact="'$' + event.param.$key"/>
      <set_value name="$id" exact="event.param.$id"/>
      
      <!-- Look up the action; error if not found. -->
      <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>

      <!-- Loop over possible event types; each gets its own entry. -->
      <do_for_each name="$event" in="['onPress','onRelease','onRepeat']">
        <!-- Skip if the action doesn't use this event. -->
        <do_if value="not $action.{'$' + $event}?">
          <continue/>
        </do_if>
        <!-- Create the full key, by suffixing with event type. -->
        <set_value name="$key_event" exact="$key +' '+ $event"/>
              
        <!-- Make sure there is a table entry for the key. -->
        <do_if value="not Globals.$key_event_action_registry.{$key_event}?">
          <set_value name="Globals.$key_event_action_registry.{$key_event}" exact="[]"/>
          <!-- Record the key (no $) and event name for later lookup. -->
          <set_value name="Globals.$key_event_substrings.{$key_event}" exact="[event.param.$key, $event]"/>
        </do_if>

        <!-- Check if the id is already recorded for this key. -->
        <do_if value="Globals.$key_event_action_registry.{$key_event}.indexof.{$id} != 0">
          <!-- Print some warning. -->
          <debug_text text="'Warning, action %s already registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_if>
        <do_else>
          <!-- It isn't recorded, so add it in. -->
          <append_to_list name="Globals.$key_event_action_registry.{$key_event}" exact="$id" />
          <debug_text text="'Action %s registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_else>
        
      </do_for_each>

      <!-- Update the server. If it isn't connected, ignore any error. -->
      <signal_cue_instantly cue="Register_Keys_With_Server"/>

      <!-- Make sure the read loop is started, if it wasn't already. -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
    </actions>
  </cue>


  <!--@doc-cue  
    Function to unregister a key from an action.     
    Params are the same as for Register_Key.
        
    Usage example:
      ```xml
        <signal_cue_instantly 
          cue="md.Hotkey_API.Unregister_Key" 
          param="table[$key='shift w', $id='my_registered_key']"/>
      ```
  -->
  <cue name="Unregister_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$key" exact="'$' + event.param.$key"/>
      <set_value name="$id" exact="event.param.$id"/>

      <!-- Look up the action; error if not found. -->
      <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>

      <!-- Loop over possible event types; each gets its own entry. -->
      <do_for_each name="$event" in="['onPress','onRelease','onRepeat']">
        <!-- Skip if the action doesn't use this event. -->
        <do_if value="not $action.{'$' + $event}?">
          <continue/>
        </do_if>
        <!-- Create the full key, by suffixing with event type. -->
        <set_value name="$key_event" exact="$key + ' ' + $event"/>

        <!-- Check if there is no table entry for the key. -->
        <do_if value="not Globals.$key_event_action_registry.{$key_event}?">
          <!-- Print some warning. -->
          <debug_text text="'Warning, key %s has no registered actions'.[$key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
          <continue/>
        </do_if>
      
        <!-- Check if the id is recorded for this key. -->
        <set_value name="$id_index" exact="Globals.$key_event_action_registry.{$key_event}.indexof.{$id}"/>
        <do_if value="$id_index == 0">
          <!-- It isn't recorded, so print a warning. -->
          <debug_text text="'Warning, action %s is not registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
          <continue/>
        </do_if>

        <!-- Proceed with removal. -->
        <remove_value name="Globals.$key_event_action_registry.{$key_event}.{$id_index}" />
        <debug_text text="'Removed action %s from key %s'.[$id, $key_event]"
                    chance="Globals.$DebugChance" filter="general"/>

        <!-- Check if the key's cue list is empty, and remove it if so. -->
        <do_if value="Globals.$key_event_action_registry.{$key_event}.count == 0">
          <remove_value name="Globals.$key_event_action_registry.{$key_event}" />
          <debug_text text="'No remaining listeners to key %s; removing it'.[$key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_if>
      </do_for_each>

      <!-- Update the server. If it isn't connected, ignore any error. -->
      <signal_cue_instantly cue="Register_Keys_With_Server"/>
      
    </actions>
  </cue>



  <!-- ################################################################## -->
  <!--                          Lua events                                -->
  <!-- ################################################################## -->
  
  <!--
    Capture lua signal on a direct-input event key press.
    This happens when the player is entering text into a text box,
    eg. the chat window, ship renaming, etc.
    
    The lua side will first send a "disable" event, wait some period of
    time, then send an "enable" event. The goal is that any corresponding
    hotkey matches should be received in the window and suppressed.
    
    Note: this solution isn't perfect, and may suppress a legit hotkey
    entered right after finishing with an edit box (relatively low impact),
    or may allow a direct input key to match a hotkey if there is a large
    latency hiccup between server and local handler.
    TODO: think about more robust ways to suppress keys under latency.
  -->
  <cue name="Capture_Lua_Disable" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'disable'" />
    </conditions>
    <actions>
      <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;disabling...'"/>-->
      <set_value name="Globals.$disabled" exact="true"/>
    </actions>
  </cue>

  <cue name="Capture_Lua_Enable" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'enable'" />
    </conditions>
    <actions>
      <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;enabling...'"/>-->
      <set_value name="Globals.$disabled" exact="false"/>
    </actions>
  </cue>
  

  <!--
    Capture lua signals when the player assigns a new key.
      
    Lua's passed param will be a table with:
    * new_key
      - New key combo, or blank string.
    * old_key
      - Prior key combo, or blank string.
    * id
      - Action id
  -->
  <cue name="Capture_Lua_Key_Update" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Update_Key'" />
    </conditions>

    <actions>
      <!-- Rename the args. -->
      <set_value name="$args" exact="event.param3" />
      <debug_text text="'Args: %s'.[$args]" chance="Globals.$DebugChance" filter="general"/>

      <!-- If there was a prior key, unregister it. -->
      <do_if value="$args.$old_key != ''">
        <signal_cue_instantly cue="Unregister_Key" 
                              param="table[$key=$args.$old_key, $id=$args.$id]"/>
      </do_if>

      <!-- If there is a new key, register it. -->
      <do_if value="$args.$new_key != ''">
        <signal_cue_instantly cue="Register_Key" 
                              param="table[$key = $args.$new_key, $id = $args.$id]"/>
      </do_if>

    </actions>
  </cue>


  <!--
    Capture lua signals to store the list of player keys.
    Generally called at the same time as Update_Key, but kept separate
    for now.
    The keys are passed on the player blackboard.
  -->
  <cue name="Capture_Lua_Store_Player_Keys" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Store_Player_Keys'" />
    </conditions>
    <actions>
      <set_value name="Globals.$player_action_keys" 
                 exact="player.entity.$hotkey_api_player_keys_from_lua"/>
      <remove_value name="player.entity.$hotkey_api_player_keys_from_lua"/>      
      <!--Make sure the userdata is updated to store the keys.-->
      <include_actions ref="Update_Userdata"/>
    </actions>
  </cue>

  <!--
    Capture menu open/close events.
    This updates menu_states and in_menu.
  -->
  <library name="Lib_Update_Menu_Status">
    <actions>
      <!--Set the flag false initially, back to true on any menu open.-->
      <set_value name="Globals.$in_menu" exact="false"/>
      <set_value name="Globals.$in_protected_menu" exact="false"/>
      
      <do_all exact="Globals.$menu_states.keys.list.count" counter="$i">
        <set_value name="$key" exact="Globals.$menu_states.keys.list.{$i}"/>
        
        <!-- Check if this menu is open. -->
        <do_if value="Globals.$menu_states.{$key}">
          <set_value name="Globals.$in_menu" exact="true"/>
          
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Menu open: %s'.[$key]"/>-->
          
          <!-- Check if the protected options menu is open. -->
          <do_if value="$key == 'OptionsMenu'">
            <set_value name="Globals.$in_protected_menu" exact="true"/>
          </do_if>
          
        </do_if>
      </do_all>
      <!--<debug_text text="'Globals.$in_menu = %1'.[Globals.$in_menu]"
                  chance="Globals.$DebugChance" filter="general"/>-->
    </actions>
  </library>
  
  <cue name="Capture_Lua_Menu_Opened" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Menu_Opened'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="true"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
  
  <cue name="Capture_Lua_Menu_Closed" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Menu_Closed'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="false"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                         Key Press Handling                         -->
  <!-- ################################################################## -->
  
  <!--
    Handle key press events.
    The python originally packaged these together to reduce signal overhead
    (after key repetition got sluggish as separate messages), so a single
    message handles all keys in a period of time.
    A list of key combos should be in the event.param3.
  -->
  <cue name="Handle_Events" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'handle_events'" />
    </conditions>
    <actions>
      <!-- Read succeeded with at least one key. -->
      <!-- Handle callback cues. -->
      <do_for_each name="$key_event" in="event.param3">
        <!-- Start by prefixing the key combo with a '$' for table lookups.
            Removed; done in lua.
        <set_value name="$key_event" exact="'$' + event.param"/> -->              

        <debug_text text="'Received key event %s'.[$key_event]"
                    chance="Globals.$DebugChance" filter="general"/>
        <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Received key event %s'.[$key_event]"/>-->
      
        <!-- Ignore if currently in a protected menu. -->
        <do_if value="Globals.$in_protected_menu">
          <debug_text text="'Ignoring key; protected menu open'"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Ignoring key; protected menu open'"/>-->
        </do_if>
      
        <!--Ignore if disabled after direct input.-->
        <do_elseif value="Globals.$disabled">
          <debug_text text="'Ignoring key; temporarily disabled after direct text input'"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Ignoring key; direct input disabled'"/>-->
        </do_elseif>

        <!-- Is the key returned actually registered? -->
        <do_elseif value="Globals.$key_event_action_registry.{$key_event}?">
        
          <!-- Determine the current player context. -->
          <!-- TODO: maybe pack into chained if/then/else expression. -->
          <!-- If any menu is open, then in a menu. -->
          <do_if value="Globals.$in_menu">
            <set_value name="$context" exact="'menus'"/>
          </do_if>
          <!-- Otherwise if piloting a ship, then flying. -->
          <do_elseif value="player.occupiedship">
            <set_value name="$context" exact="'flying'"/>
          </do_elseif>
          <!-- Otherwise walking around. -->
          <do_else>
            <set_value name="$context" exact="'walking'"/>
          </do_else>

          <debug_text text="'Context of key: %s'.[$context]"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Context of key: %s'.[$context]"/>-->
        
          <!-- Get the event associated with this key/event, matching its suffix. -->
          <set_value name="$key" exact ="Globals.$key_event_substrings.{$key_event}.{1}"/>
          <set_value name="$event" exact ="Globals.$key_event_substrings.{$key_event}.{2}"/>
        
          <!-- Loop over the action ids. -->
          <do_for_each name="$id" in="Globals.$key_event_action_registry.{$key_event}">
          
            <!-- Get the actual action info. -->
            <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>
          
            <!-- Determine if this action is valid at this time. -->
            <set_value name="$valid" exact="false"/>
          
            <!-- General context check. -->
            <do_if value="$action.$contexts.indexof.{$context} != 0">
              <set_value name="$valid" exact="true"/>
            </do_if>
          
            <!-- If in menu and menu names were given, check specific name. -->
            <do_elseif value="Globals.$in_menu and ($action.$menu_names?)">
              <!-- Go through all menu names and see if any are open. -->
              <do_for_each name="$menu_name" in="$action.$menu_names">
                <!--Check this is a tracked menu, and in an open state.-->
                <do_if value="Globals.$menu_states.{$menu_name}? and Globals.$menu_states.{$menu_name}">
                  <!-- This menu is open, so flag as valid. -->
                  <set_value name="$valid" exact="true"/>
                  <!-- Update the context for cue callback. -->
                  <set_value name="$context" exact="$menu_name"/>
                  <break/>
                </do_if>
              </do_for_each>
            </do_elseif>
          
            <!-- Skip if not a valid context. -->
            <do_if value="not $valid">
              <debug_text text="'Skipping due to context mismatch'"
                          chance="Globals.$DebugChance" filter="general"/>
              <continue/>
            </do_if>
          
            <!-- Look up the cue to callback to. -->
            <!-- (In the current setup, the cue should always be found.) -->
            <set_value name="$cue" exact="@$action.{'$'+$event}"/>
          
            <!-- Call it if it still exists. -->
            <do_if value="$cue.exists">
              <debug_text text="'Signalling cue: %s'.[$cue]"
                          chance="Globals.$DebugChance" filter="general"/>
              <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Signalling cue: %s'.[$cue]"/>-->
              <!-- Call the cue, with return values. -->
              <signal_cue_instantly cue="$cue" param="table[
                                    $key     = $key,
                                    $id      = $id,
                                    $context = $context,
                                    $event   = $event,
                                    $echo    = $action.$echo
                                    ]"/>
            </do_if>
            <!-- TODO: delink keys from non-existent actions/cues. -->
            <!--Could do this by removing the $event from the action, 
                unregistering, and reregistering.-->          
          </do_for_each>
        </do_elseif>

        <do_else>
          <!-- Key not registered. TODO: error message. -->
          <debug_text text="'Ignoring key; no registered events'"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_else>
      </do_for_each>
    </actions>
  </cue>


  <!-- Set up a menu option to turn on/off the debug logging. -->
  <cue name="Set_Menu_Options" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Simple_Menu_Options.Reloaded"/>
    </conditions>
    <actions>
      <!--TODO: maybe hide this unless in developer mode (how to know?)-->
      <signal_cue_instantly
        cue="md.Simple_Menu_Options.Register_Option"
        param = "table[
            $category   = Text.$Debug,
            $id         = 'debug_hotkey_api',
            $name       = Text.$option_debug_enable,
            $mouseover  = Text.$option_debug_enable_mouseover,
            $default    = 0,
            $type       = 'button',
            $callback   = On_Option_Change,
            ]"/>
    </actions>
  </cue>

  <cue name="On_Option_Change" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
      <set_value name="$id"    exact="event.param.$id"/>
      <set_value name="$value" exact="event.param.$value"/>

      <do_if value="$id == 'debug_hotkey_api'">
        <!-- Change the debug chance in the main md file. -->
        <set_value name="Globals.$DebugChance"
                   exact ="if ($value) then 100 else 0"/>
      </do_if>
    </actions>
  </cue>


</cues>
</mdscript>